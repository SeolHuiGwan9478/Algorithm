# 뼈대 코드가 없으니 입력 처리 코드도 직접 작성할 것!
# code here
def Rotate_count(L,i,j):
	count = 0 #C
	if i == j: 
		return 0 
	m = (i+j)//2 #C
	if L[i] < L[m+1]:
		count += Rotate_count(L,m+1,j) #T(n/2) + C, (함수 재귀호출) + (+,= 연산)
	else:
		count += j-m #C
		count += Rotate_count(L,i,m) #T(n/2) + C, (함수 재귀) + (+,= 연산)
	return count
#T(n) = T(n/2) + C -> O(log n)
A = [int(x) for x in input().split()]
k = Rotate_count(A,0,len(A)-1)
print(k)
# 질문. 본인의 알고리즘의 비교횟수를 분석한 후, Big-O로 표기해보자
# 대답
# 로테이션을 한 것인지 확인하기 위해서는 큰 수 뒤에 작은수가 있는지 확인하여야 한다. 
# 반으로 쪼개서 나뉜 부분의 첫번째 원소를 확인했을때, 왼쪽이 크면 이것은 로테이션 됐다는 것을 의미한다.
# 왜냐하면 로테이션이 되지 않았다면 오름차순으로 정렬되어있기 때문에 반으로 쪼개서 각 부분의 첫번째 원소를 확인했을때, 오른쪽이 더 커야한다.
# 계속해서 쪼개나가면서 큰 수 뒤에 작은수가 있는지 판단한 것이다. 재귀적으로 큰수가 있는 부분을 함수에 넣어주면서 count해준 것이다.
# 재귀 부분 이외에는 =,+ 등의 기본연산으로 상수 C시간 걸리기에 T(n) += C
# 그리고 재귀 부분은 반으로 쪼개서 재귀함수호출->T(n) += T(n/2), 분할해서 리턴받아온 것을 다시 count에 더해주어야 하기 때문에 기본연산 등이 필요하다->T(n) += C 
# T(n) = T(n/2) + C (C는 상수라 가정),점화식을 풀면 O(log n). 